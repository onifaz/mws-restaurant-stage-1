{"version":3,"sources":["idb.js","dbhelper.js","observer.js","swregister.js"],"names":["promisifyRequest","request","Promise","resolve","reject","onsuccess","result","onerror","error","promisifyRequestCall","obj","method","args","p","apply","then","proxyProperties","ProxyClass","targetProp","properties","forEach","prop","Object","defineProperty","prototype","get","this","set","val","proxyRequestMethods","Constructor","arguments","proxyMethods","proxyCursorRequestMethods","value","Cursor","Index","index","_index","cursor","_cursor","_request","ObjectStore","store","_store","Transaction","idbTransaction","_tx","complete","oncomplete","onabort","UpgradeDB","db","oldVersion","transaction","_db","DB","IDBIndex","IDBCursor","methodName","createIndex","IDBObjectStore","objectStore","IDBTransaction","createObjectStore","IDBDatabase","funcName","replace","arr","Array","slice","call","callback","length","nativeObject","getAll","query","count","instance","items","iterateCursor","push","undefined","continue","exp","open","name","version","upgradeCallback","indexedDB","onupgradeneeded","event","delete","module","exports","default","self","idb","DBHelper","REST_URL","IDB_NAME","IDB_VERSION","IDB_STORE_RESTAURANTS","IDB_STORE_REVIEWS","[object Object]","window","navigator","serviceWorker","upgrade","storeRestaurants","keyPath","autoIncrement","storeReviews","unique","openIDB","idb_data","fetch","response","json","restaurants","restaurant","put","catch","err","console","warn","id","fetchRestaurants","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","photograph","sizes","imagePictureforRestaurant","imageErrorForRestaurant","div","document","createElement","image","className","setAttribute","append","picture","sourcew","imageSrcsetForRestaurant","sourcej","imageName","ext","google","maps","Marker","position","latlng","title","url","urlForRestaurant","animation","Animation","DROP","parseInt","restaurant_id","info","reviews","review","createdAt","Date","valueOf","updatedAt","fetchReviewsForRestaurant","log","hasOwnProperty","body","JSON","stringify","server_response","insertReviewIDB","pendingUpload","_","state","is_favorite","updateRestaurantInDb","openCursor","reuploadFavorites","favoriteRestaurant","reuploadReview","removeReviewIDb","saveReview","reviewId","observer","observerConfig","rootMargin","threshold","loadImage","el","dataset","srcset","src","onIntersection","elements","intersectionRatio","unobserve","target","lazyload","images","querySelectorAll","IntersectionObserver","observe","from","register","ready","swRegistration","sync","syncAllData"],"mappings":"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","file":"bundle.js","sourcesContent":["'use strict';\n\n(function() {\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(\n    ProxyClass,\n    targetProp,\n    Constructor,\n    properties\n  ) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(\n    ProxyClass,\n    targetProp,\n    Constructor,\n    properties\n  ) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', ['name', 'keyPath', 'multiEntry', 'unique']);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, ['update', 'delete']);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, ['deleteIndex']);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', ['objectStoreNames', 'mode']);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, ['abort']);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(\n      this._db.createObjectStore.apply(this._db, arguments)\n    );\n  };\n\n  proxyProperties(UpgradeDB, '_db', ['name', 'version', 'objectStoreNames']);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, ['deleteObjectStore', 'close']);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', ['name', 'version', 'objectStoreNames']);\n\n  proxyMethods(DB, '_db', IDBDatabase, ['close']);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(\n          nativeObject,\n          args.slice(0, -1)\n        );\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  var exp = {\n    open: function(name, version, upgradeCallback) {\n      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n      var request = p.request;\n\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(\n            new UpgradeDB(request.result, event.oldVersion, request.transaction)\n          );\n        }\n      };\n\n      return p.then(function(db) {\n        return new DB(db);\n      });\n    },\n    delete: function(name) {\n      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n    }\n  };\n\n  if (typeof module !== 'undefined') {\n    module.exports = exp;\n    module.exports.default = module.exports;\n  } else {\n    self.idb = exp;\n  }\n})();\n","/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n  /**\r\n   * REST Api URL -> Pointing to mws-restaurant-page-2 server\r\n   * Change this to the URL of your server.\r\n   */\r\n  static get REST_URL() {\r\n    const port = 1337; // Change this to your server port\r\n    return `http://localhost:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * IDB name\r\n   */\r\n  static get IDB_NAME() {\r\n    return 'restareviews';\r\n  }\r\n  /**\r\n   * iDB version\r\n   */\r\n  static get IDB_VERSION() {\r\n    return 2;\r\n  }\r\n  /**\r\n   * iDB store name for restaurants\r\n   */\r\n  static get IDB_STORE_RESTAURANTS() {\r\n    return 'restaurants';\r\n  }\r\n\r\n  /**\r\n   * iDB store name for reviews\r\n   */\r\n  static get IDB_STORE_REVIEWS() {\r\n    return 'reviews';\r\n  }\r\n\r\n  /**\r\n   * Get indexDB (better -> get IDB but promised)\r\n   */\r\n  static openIDB() {\r\n    // If the browser doesn't support service worker,\r\n    // we don't care about having a database\r\n    if (self.window && !navigator.serviceWorker) {\r\n      return Promise.resolve();\r\n    }\r\n    return idb.open(DBHelper.IDB_NAME, DBHelper.IDB_VERSION, upgrade => {\r\n      const storeRestaurants = upgrade.createObjectStore(\r\n        DBHelper.IDB_STORE_RESTAURANTS,\r\n        {\r\n          keyPath: 'id',\r\n          autoIncrement: true\r\n        }\r\n      );\r\n      const storeReviews = upgrade.createObjectStore(\r\n        DBHelper.IDB_STORE_REVIEWS,\r\n        {\r\n          keyPath: 'id',\r\n          autoIncrement: true\r\n        }\r\n      );\r\n      storeRestaurants.createIndex('pending-upload', 'pendingUpload', {\r\n        unique: false\r\n      });\r\n      storeReviews.createIndex('pending-upload', 'pendingUpload', {\r\n        unique: false\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    DBHelper.openIDB()\r\n      .then(db => {\r\n        if (!db) return;\r\n        return db\r\n          .transaction(DBHelper.IDB_STORE_RESTAURANTS)\r\n          .objectStore(DBHelper.IDB_STORE_RESTAURANTS)\r\n          .getAll();\r\n      })\r\n      .then(idb_data => {\r\n        if (idb_data && idb_data.length > 0) return callback(null, idb_data);\r\n        else {\r\n          fetch(DBHelper.REST_URL + 'restaurants')\r\n            .then(response => {\r\n              //if restaurants are fetched, parse the JSON response\r\n              return response.json();\r\n            })\r\n            .then(restaurants => {\r\n              //save restaurants in db and serve the downloaded response\r\n              DBHelper.openIDB().then(db => {\r\n                if (!db) return;\r\n                const store = db\r\n                  .transaction(DBHelper.IDB_STORE_RESTAURANTS, 'readwrite')\r\n                  .objectStore(DBHelper.IDB_STORE_RESTAURANTS);\r\n                restaurants.forEach(function(restaurant) {\r\n                  store.put(restaurant);\r\n                });\r\n              });\r\n              return callback(null, restaurants);\r\n            })\r\n            .catch(err => {\r\n              console.warn('Request failed. Returned status of', err);\r\n            });\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) {\r\n          // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else {\r\n          // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(\r\n    cuisine,\r\n    neighborhood,\r\n    callback\r\n  ) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants;\r\n        if (cuisine != 'all') {\r\n          // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') {\r\n          // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map(\r\n          (v, i) => restaurants[i].neighborhood\r\n        );\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter(\r\n          (v, i) => neighborhoods.indexOf(v) == i\r\n        );\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter(\r\n          (v, i) => cuisines.indexOf(v) == i\r\n        );\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return `./restaurant.html?id=${restaurant.id}`;\r\n  }\r\n\r\n  /**\r\n   * Restaurant page image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    if (!restaurant.photograph) {\r\n      return DBHelper.imageErrorForRestaurant(restaurant);\r\n    } else {\r\n      // ref, for sizes and srcset\r\n      //basic -->small+medium\r\n      //media=\"(min-width:401px) and (max-width:600px), (min-width:992px) and (max-width:1199)\" -->medium + normal\r\n      //media=\"(min-width:601px) and (max-width:991px), (min-width:1200px)\" --> normal\r\n      //sizes=\"(max-width:991px) 100vw, 50vw\"\r\n      const sizes = '(max-width:991px) 75vw, 45vw';\r\n      return DBHelper.imagePictureforRestaurant(restaurant, sizes);\r\n    }\r\n  }\r\n  /**\r\n   * Home page image URL.\r\n   */\r\n  static imageUrlForRestaurants(restaurant) {\r\n    if (!restaurant.photograph) {\r\n      return DBHelper.imageErrorForRestaurant(restaurant);\r\n    } else {\r\n      const sizes =\r\n        '(max-width: 679px) 400px, (max-width: 989px) and (min-width: 680px) 48vw, (min-width:990px) 350px, (min-width:1780px) 400px';\r\n      return DBHelper.imagePictureforRestaurant(restaurant, sizes);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Error image\r\n   */\r\n  static imageErrorForRestaurant(restaurant) {\r\n    const div = document.createElement('div');\r\n    const image = document.createElement('img');\r\n    div.className = 'restimage-wrap';\r\n    image.className = 'restaurant-img';\r\n    //image.src = 'img/no-image-available.svg';\r\n    image.setAttribute('data-src', 'img/no-image-available.svg');\r\n    image.setAttribute(\r\n      'alt',\r\n      'No photo available for ' + restaurant.name + ' restaurant'\r\n    );\r\n    div.append(image);\r\n    return div;\r\n  }\r\n\r\n  /**\r\n   * Create picture for image\r\n   */\r\n  static imagePictureforRestaurant(restaurant, sizes) {\r\n    const picture = document.createElement('picture');\r\n    const sourcew = document.createElement('source');\r\n    sourcew.setAttribute('sizes', sizes);\r\n    sourcew.setAttribute('type', 'image/webp');\r\n    /*sourcew.setAttribute(\r\n      'srcset',\r\n      DBHelper.imageSrcsetForRestaurant(restaurant.photograph, 'webp')\r\n    );*/\r\n    sourcew.setAttribute(\r\n      'data-srcset',\r\n      DBHelper.imageSrcsetForRestaurant(restaurant.photograph, 'webp')\r\n    );\r\n    picture.append(sourcew);\r\n    const sourcej = document.createElement('source');\r\n    sourcej.setAttribute('sizes', sizes);\r\n    /*sourcej.setAttribute(\r\n      'srcset',\r\n      DBHelper.imageSrcsetForRestaurant(restaurant.photograph, 'jpg')\r\n    );*/\r\n    sourcej.setAttribute(\r\n      'data-srcset',\r\n      DBHelper.imageSrcsetForRestaurant(restaurant.photograph, 'jpg')\r\n    );\r\n    picture.append(sourcej);\r\n    const image = document.createElement('img');\r\n    image.className = 'restaurant-img';\r\n    //image.src = `img/restaurants/${restaurant.photograph}.jpg`;\r\n    image.setAttribute(\r\n      'data-src',\r\n      `img/restaurants/${restaurant.photograph}.jpg`\r\n    );\r\n    image.setAttribute('alt', 'Photo of ' + restaurant.name + ' restaurant');\r\n    picture.append(image);\r\n    return picture;\r\n  }\r\n\r\n  /**\r\n   * Create srcset string\r\n   */\r\n  static imageSrcsetForRestaurant(imageName, ext) {\r\n    return `img/restaurants/${imageName}.${ext} 860w, img/restaurants/${imageName}-720.${ext} 780w, img/restaurants/${imageName}-540.${ext} 580w, img/restaurants/${imageName}-350.${ext} 420w`;\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP\r\n    });\r\n    return marker;\r\n  }\r\n\r\n  /**\r\n   * Retrieve review per specific restaurant id\r\n   */\r\n  static fetchReviewsForRestaurant(id, callback) {\r\n    DBHelper.openIDB()\r\n      .then(db => {\r\n        if (!db) return;\r\n        return db\r\n          .transaction(DBHelper.IDB_STORE_REVIEWS)\r\n          .objectStore(DBHelper.IDB_STORE_REVIEWS)\r\n          .getAll();\r\n      })\r\n      .then(idb_data => {\r\n        id = parseInt(id); //for next strict comparison\r\n        idb_data = idb_data.filter(r => r.restaurant_id === id);\r\n        if (idb_data && idb_data.length > 0) {\r\n          console.info('Reviews served from IDB');\r\n          return callback(null, idb_data);\r\n        } else {\r\n          console.info('Reviews fetched from online server');\r\n          fetch(DBHelper.REST_URL + 'reviews/?restaurant_id=' + id)\r\n            .then(response => {\r\n              //if restaurants are fetched, parse the JSON response\r\n              return response.json();\r\n            })\r\n            .then(reviews => {\r\n              // \"normalize\" date between origina lserver data and newest reviews\r\n              reviews.forEach(function(review) {\r\n                review.createdAt = new Date(review.createdAt).valueOf();\r\n                review.updatedAt = new Date(review.updatedAt).valueOf();\r\n              });\r\n              //save restaurants in db and serve the downloaded response\r\n              DBHelper.openIDB().then(db => {\r\n                if (!db) return;\r\n                const store = db\r\n                  .transaction(DBHelper.IDB_STORE_REVIEWS, 'readwrite')\r\n                  .objectStore(DBHelper.IDB_STORE_REVIEWS);\r\n                reviews.forEach(function(review) {\r\n                  store.put(review);\r\n                });\r\n              });\r\n              return callback(null, reviews);\r\n            })\r\n            .catch(err => {\r\n              //console.error('Request failed. Returned status of', err);\r\n              console.warn('Request failed');\r\n              return callback(err, null);\r\n            });\r\n        }\r\n      });\r\n  }\r\n  /**\r\n   * Fetch reviews by restaurant id\r\n   */\r\n  static fetchReviewsByRestaurantId(id, callback) {\r\n    DBHelper.fetchReviewsForRestaurant(id, (error, reviews) => {\r\n      if (error) callback(error, null);\r\n      else {\r\n        const reviewsList = reviews;\r\n        if (reviewsList) {\r\n          // Got the reviews\r\n          callback(null, reviewsList);\r\n        } else {\r\n          // Couldn't find reviews in the database\r\n          callback('Reviews do not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Send the review to the server and also save it in db\r\n   */\r\n  static saveReview(review) {\r\n    if (!review) return;\r\n    console.log(review.hasOwnProperty('id'));\r\n    return fetch(DBHelper.REST_URL + 'reviews', {\r\n      method: 'POST',\r\n      body: JSON.stringify(review)\r\n    })\r\n      .then(response => {\r\n        //review.pendingUpload = 'no';\r\n        return response.json();\r\n      })\r\n      .then(server_response => {\r\n        review = server_response;\r\n        //console.table(review);\r\n        //uniform date with old reviews\r\n        review.createdAt = new Date(review.createdAt).valueOf();\r\n        review.updatedAt = new Date(review.updatedAt).valueOf();\r\n        return DBHelper.insertReviewIDB(review);\r\n      })\r\n      .catch(err => {\r\n        console.warn('Post review request failed. Error: ', err);\r\n        review.pendingUpload = 'yes';\r\n        review.createdAt = new Date().valueOf();\r\n        review.updatedAt = new Date().valueOf();\r\n        //insert temporary idb record\r\n        return DBHelper.insertReviewIDB(review, _ => {\r\n          console.warn('Pending review record inserted in IDB - ', review);\r\n        });\r\n      });\r\n  }\r\n  /**\r\n   * Add review to IDB\r\n   */\r\n  static insertReviewIDB(review, callback) {\r\n    return DBHelper.openIDB()\r\n      .then(db => {\r\n        if (!db) return;\r\n        const tx = db\r\n          .transaction(DBHelper.IDB_STORE_REVIEWS, 'readwrite')\r\n          .objectStore(DBHelper.IDB_STORE_REVIEWS)\r\n          .put(review);\r\n        return tx.complete;\r\n      })\r\n      .then(_ => {\r\n        if (typeof callback === 'function') callback();\r\n        console.log('review added in IDB');\r\n        return review;\r\n      })\r\n      .catch(err => {\r\n        console.warn('Add review in IDB failed. Error:', err);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Add review to IDB\r\n   */\r\n  static favoriteRestaurant(restaurant, state) {\r\n    if (!restaurant) return;\r\n    restaurant.is_favorite = state;\r\n    fetch(\r\n      DBHelper.REST_URL +\r\n        'restaurants/' +\r\n        restaurant.id +\r\n        '/?is_favorite=' +\r\n        state,\r\n      {\r\n        method: 'PUT'\r\n      }\r\n    )\r\n      .then(response => {\r\n        //console.table(restaurant);\r\n        //restaurant.pendingUpload = 'no';\r\n        DBHelper.updateRestaurantInDb(restaurant);\r\n      })\r\n      .catch(err => {\r\n        console.warn('Post favorite request failed. Error: ', err);\r\n        restaurant.pendingUpload = 'yes';\r\n        //insert temporary idb record\r\n        DBHelper.updateRestaurantInDb(restaurant, _ => {\r\n          console.warn(\r\n            'Pending favorite record inserted in IDB - ',\r\n            restaurant.id\r\n          );\r\n        });\r\n      });\r\n  }\r\n  /**\r\n   * Update idb restaurant record\r\n   */\r\n  static updateRestaurantInDb(restaurant, callback) {\r\n    DBHelper.openIDB().then(db => {\r\n      if (!db) return;\r\n      db.transaction(DBHelper.IDB_STORE_RESTAURANTS, 'readwrite')\r\n        .objectStore(DBHelper.IDB_STORE_RESTAURANTS)\r\n        .put(restaurant);\r\n      if (typeof callback === 'function') callback();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sync database data (restaurants & reviews)\r\n   */\r\n  static syncAllData() {\r\n    console.info('Syncing all the data with the server');\r\n\r\n    // for restaurants' favorites\r\n    DBHelper.openIDB()\r\n      .then(db => {\r\n        if (!db) return;\r\n        console.info('Syncing favorites...');\r\n        return db\r\n          .transaction(DBHelper.IDB_STORE_RESTAURANTS)\r\n          .objectStore(DBHelper.IDB_STORE_RESTAURANTS)\r\n          .index('pending-upload')\r\n          .openCursor('yes');\r\n      })\r\n      .then(function reuploadFavorites(cursor) {\r\n        if (!cursor) return;\r\n        let restaurant = cursor.value;\r\n        delete restaurant.pendingUpload;\r\n        DBHelper.favoriteRestaurant(restaurant, restaurant.is_favorite);\r\n        return cursor.continue().then(reuploadFavorites);\r\n      });\r\n\r\n    // for restaurants' reviews\r\n    DBHelper.openIDB()\r\n      .then(db => {\r\n        if (!db) return;\r\n        console.info('Syncing reviews...');\r\n        return db\r\n          .transaction(DBHelper.IDB_STORE_REVIEWS)\r\n          .objectStore(DBHelper.IDB_STORE_REVIEWS)\r\n          .index('pending-upload')\r\n          .openCursor('yes');\r\n      })\r\n      .then(function reuploadReview(cursor) {\r\n        if (!cursor) return;\r\n        let review = cursor.value;\r\n        DBHelper.removeReviewIDb(review.id, () => {\r\n          delete review.pendingUpload;\r\n          DBHelper.saveReview(review);\r\n        });\r\n\r\n        return cursor.continue().then(reuploadReview);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Delete a review from IDB\r\n   */\r\n  static removeReviewIDb(reviewId, callback) {\r\n    DBHelper.openIDB().then(db => {\r\n      if (!db) return;\r\n      db.transaction(DBHelper.IDB_STORE_REVIEWS, 'readwrite')\r\n        .objectStore(DBHelper.IDB_STORE_REVIEWS)\r\n        .delete(reviewId);\r\n      if (typeof callback === 'function') callback();\r\n    });\r\n  }\r\n}\r\n","let observer;\nconst observerConfig = {\n  rootMargin: '40px 0%',\n  threshold: 0.1\n};\nlet loadImage = el => {\n  //console.log(el.dataset);\n  if (el.dataset && el.dataset.srcset) {\n    el.srcset = el.dataset.srcset;\n  }\n  if (el.dataset && el.dataset.src) {\n    el.src = el.dataset.src;\n  }\n};\nlet onIntersection = elements => {\n  elements.forEach(el => {\n    if (el.intersectionRatio > 0) {\n      observer.unobserve(el.target);\n      //console.log('Intersection!');\n      //console.log(el.target);\n      loadImage(el.target);\n    }\n  });\n};\nfunction lazyload() {\n  const images = window.document.querySelectorAll('source, img');\n  if (!('IntersectionObserver' in window)) {\n    console.log('Intersection Observer not found :(');\n    Array.from(images).forEach(image => loadImage(image));\n  } else {\n    //console.log('intersection loaded!');\n    observer = new IntersectionObserver(onIntersection, observerConfig);\n    images.forEach(image => {\n      observer.observe(image);\n    });\n  }\n}\n","/**\n * Register the service worker.\n */\nif (navigator.serviceWorker) {\n  navigator.serviceWorker\n    .register('/sw.js')\n    .then(_ => {\n      console.log('SW is registered!');\n      // Then later, request a one-off sync:\n      navigator.serviceWorker.ready\n        .then(function(swRegistration) {\n          console.log('registerwhenready');\n          return swRegistration.sync.register('dataSync');\n        })\n        .catch(function() {\n          // system was unable to register for a sync, this could be an OS-level restriction\n          DBHelper.syncAllData();\n        });\n    })\n    .catch(err => console.log('SW registration ', err));\n}\n"]}